---
layout: post
title:  "微服务设计笔记"
categories: 
tags: 微服务 读书笔记
author: 若水三千
---

* content
{:toc}

# 第一章

## 1.1 微服务

### 1.1.1 很小，专注做好一件事

单一职责
Single Responsibility Principle

http://programmer.97things.oreilly.com/wiki/index.php/The_Single_Responsibility_Principle把因相同原因变化的东西聚合在一起，把因不同原因变化的东西分离。

Hexagonal Architecture——Alistair Cockburn, 解耦业务，借助虚拟化，自动对服务进行从一台扩展到多台。根据业务划分服务的边界。《领域驱动设计》 Eric Evans


领域驱动设计、持续交付、虚拟化、基础设施自动化、小型自治团队、集群系统中实践产生微服务。


RealEstate.com.au Jon Eaves: “一个微服务应该可以在两周内完全重写。”


### 1.1.2 自治性

可以独立部署在PAAS(Platfoorm As a Service)，也可以作为一个操作系统进程存在。docker
需要考虑暴露和隐藏的服务有API粒度，API的不依赖特定技术实现。（RESTFul  <---> JSONP）

衡量法则：是否能修改一个服务进行部署，而不影响其他任何服务。


## 1.2 优点

### 1.2.1 技术异构

不同服务中使用适合的技术。不同不服使用不同数据存储技术。如，社交网络，图数据库。论坛，文档数据库

### 1.2.2 弹性

分布式改机了弹性，需要关注网络通信问题

### 1.2.3 扩展

### 1.2.4 简化部署

### 1.2.5 与组织结构相匹配

### 1.2.6 可组合性

复用，组合便捷

### 1.2.7 对可替代性的优化


## 1.3 面向服务的架构
SOA (Service-Oriented Architecture) 服务独立存在，通过网络进行调用如RPC。实施中问题：通信协议（SOAP）的选择、第三方中间件选择、
服务粒度。

## 1.4 其他分解技术
### 1.4.1 共享库
无法选择异构技术，语言和平台限制。动态链接库技术（dll、so）

### 1.4.2 模块

OSGI（Open Source Gateway Initative，开放服务网关协议），Eclipse plugin-in
强调声明周期的管理，模块隔离设计困难。
Erlang内嵌模块

## 1.5 缺点
分布式系统的复杂性，部署、测试、监控、系统扩展、分布式事务和CAP


# 第二章 演化式架构师

## 2.1 不恰当的对不

## 2.2 架构师演化视角

适合根据用户需求进行演化/进化的架构。

避免过于详尽的设计、要能根据需求随时做出相应的响应。保证开发人员在该系统上进行工作。专注大的方向，应对将来的变化。

## 2.3 分区

关注服务边界，服务之间交互，保证对整个系统健康状态进行监控。服务协议（HTTP、protocol buffers、Java RMI）


## 2.4 一个原则性方法

### 2.4.1 战略目标

### 2.4.2 原则
缩短新功能上线周期
可能原则是，交付团队对整个软件生命周期具有完全控制权。
跨国企业：整个系统符合当地要求

一个可参考指导原则
Heroku 12 Factors(http://www.12factor.net)

### 2.4.3 实践

技术相关的规范，可借鉴阿里。代码规范、日志数据、HTTP/REST标准

### 2.4.4 原则和实践相结合

### 2.4.5 实例
![图 2-1 原则和实践](building microservice 2-1.png)


## 2.5 要求的标准

### 2.5.1 监控
清晰描绘跨服务系统的健康状态。系统级别上考虑。例如推送机制，使用Graphite收集指标数据，Nagios检查健康，或轮询收集。一个有益建议保持标准化，服务内技术对外不透明，不要为了服务具体实现而改变监控系统。日志也应该遵循相似标准，并且采用集中式管理方式。

### 2.5.2 接口
规范统一接口技术，如选择了HTTP/REST，URL中使用动词还是名词？资源分页的处理？不同版本的API?

## 2.5.3 架构安全
每个服务都可以应对下游服务错误请求，（重试、超时、幂等设计），每个下游服务使用自己的连接池，进一步每个服务使用一个单独断路器。返回码规范，HTTP响应码。
对以下请求做不同处理，保证系统及时失败，避免雪崩，并容易追溯问题。
- 正常并正确处理的请求
- 错误请求，服务识别除了错误，但是什么也没做
- 被访问服务宕机，无法判断请求是否正常

## 2.6 代码治理
提供范例和服务代码模板

### 2.6.1 范例
文档，wiki
代码范例，最好来自真正运行的代码。

### 2.6.2 裁剪服务代码模板
最佳实践，实现一个新服务时，所有实现核心属性那些代码都是现成的。

Dropwizard（http://dropwizard.io）和Karyon（https://github.com/Netflix/karyon）基于JVM的开源微容器。运行模式相似，自动下载一系列第三方库，提供健康检查、HTTP服务、指标数据接口等。从命令行启动的servlet容器。如果想要断路器规范化使用，可以将Hystrix集成进来，或者把所有指标数据发送到中心Graphite服务器，或者使用像Dropwizard's Metrics（https://github.com/dropwizard/metrics）这样的开源库，并进行自定义配置。Netflix使用挎斗（sidebar）服务来降低服务容错机制出错的风险。挎斗（sidebar）服务和JVM进行本地通信

## 2.7 技术债务
建立债务历史追溯列表

## 2.8 例外管理
例如，实践论述应该总是使用MySQL做数据存储，后来有足够的证据表明，海量存储场景下应该使用Cassandra，这是就可以对实践进行修正“在大多数场景下使用MySQL做存储，如果是数据快速增长的场景，可以使用Cassandra”，如果组织内对开发人员有非常多的限制，可能不太适合使用微服务技术。

## 2.9 集中治理和领导
架构师部分职责是治理COBIT（Control Objectives for Information and Related Technology信息和相关技术的控制目标）：治理通过评估干系人的需求，当前情况及下一步可能性来确保企业目标的达成，通过排优先级和做决策来设定方向。对已经达成一致的方向和目标进行监督。

了解新技术，了解什么时候做出怎样的取舍。

## 2.10 建设团队


# 第三章 如果构建服务

3.2 什么样的服务是好服务

### 3.2.1 松耦合

使用紧耦合的方式做服务之间的集成，从而使得一个服务的修改会致使消费者的修改松耦合的服务应该尽可能少的知道与之协作的那些服务的信息

### 3.2.2 高内聚
寻找问题域的边界确保相关的行为放在同一个地方


## 3.3 限界上下文

限界上下文（bounded context）其中的模型分为两部分，一部分与外部通信，另一部分不需要。每个上下文都有明确的接口，该接口决定暴露哪些模型给其他的上下文。一个由显示边界限定的特定职责。想要从其中获得信息，或发送请求，需要使用模型和它的显式边界进行通信。譬如：细胞之所以存在，是因为细胞膜定义了细胞内外，并决定什么物质可以通过细胞膜。

### 3.3.1 共享的隐藏模型

### 3.3.2 模块和服务

### 3.3.3 过早划分

## 3.4 业务功能

不从共享数据角度，从上下文能提供的功能角度进行考虑。

## 3.5 逐步划分上下文

## 3.6 业务沟通概念

## 3.7 技术边界


# 第四章 集成

## 4.1 寻找理想的集成技术
通信协议选择SOAP、XML-RPC、REST、Protocol Buffers？

### 4.1.1 避免破坏性修改
例如响应中加了一个字段。已有的消费方应该不受影响。

### 4.1.2 保证API技术独立性
不选择对微服务具体实现技术有限制的继承方式

### 4.1.3 服务易于消费方使用

### 4.1.4 隐藏内部实现细节


## 4.2 为用户创建接口

## 4.3 共享数据库
- 外部系统能看到内部实现细节
- 消费和特定技术绑定

## 4.4 同步与异步
两种通信模式有各自的协作风格，请求/响应或者基于事件。异步也可以使用请求/响应模式，发送一个请求，注册一个回调，服务端操作结束时，调用处理。基于事件协作方式，客户端发布一个事件，然后期待其他协作着接受到该消息，并且知道该怎么做。

## 4.5 编排与协同

- 编排(orchestration)  
依赖某个中心指挥驱动整个流程。中心控制点承担了过多的职责，成为网络状结构的中心枢纽和许多逻辑的起点，导致少量的“上帝”服务，与其交互的服务会变成贫血、基于CRUD的服务。  

- 协同(choreography)  
通知各部分各自的职责，具体做的细节留给自己实现。例如从客户服务使用异步触发一个事件，例如“客户创建。电子邮件、邮政服务、积分账号订阅这些事件，并进行响应处理，图4-4。缺点是无法看到明显的业务流程视图。优点，有利于程序解耦，但是需要某种技术手段对业务跨服务调用进行监控。

- 考虑因素
同步调用简单且容易知道整个工作流程是否正常。对于耗时长的服务可以使用异步请求响应加回调方式。异步也有助于协同方案的实施。请求/响应方式，可以考虑两种技术RPC（Remote Procedure Call，远程过程调用）REST（Representational State Transfer）

## 4.6 远程过程调用

允许进行一个本地调用，事实上是由某个远程服务器产生的。依赖接口定义（SOAP、Thrift、protocol buffers etc.）

### 4.6.1 技术的耦合
Java RMI和特定平台关系紧密。

### 4.6.2 本地调用和远程调用不同
RPC时间耗费在于对负荷进行封装和解封，还有网络通信的开销。本地API和跨服务API要采取不同策略。

分布式网络错误观点“网络时可靠的”<del>（https://blogs.oracle.com/jag/resource/Fallacies.html）</del>
网络故障假，网络攻击，服务器返回错误信息，请求本身问题。
<b><font color="purple"> 待解决问题，能否区分不同故障模式？可以的话，怎么分别处理？如果，因为服务刚启动，响应慢，该怎么处理？</font></b>

### 4.6.3 脆弱性
实践中，通信双方使用的数据类型会被直接序列化和反序列化。数据类型中包含大量字段时候，无法安全删除。

### 4.6.4 RPC很糟吗
protocol buffers或者Thrift会通过避免对客户端和服务端的**lock-step**发布来消除一些上述问题。 

>选用RPC注意事项  
1. 不要对远程调用过度抽象，以至于网络因素被隐藏  
2. 确保可以独立升级服务器端口而不用强迫客户端升级，编写平衡的客户端代码  
3. 客户端中不要隐藏在使用网络调用的事实  
4. 客户端库的结构组织要合理

## 4.7 REST

>     资源  
>         服务可以根据请求内容创建对象的不同表示形式，也就是说对外显示方式和内部存储之间没有什么耦合。
>     风格
>         成熟度模型
>         https://martinfowler.com/articles/richardsonMaturityModel.html

### 4.7.1 REST和HTTP
Varnish HTTP缓存代理、mod_proxy负载均衡、HTTP监控、HTTP路由

### 4.7.2 超媒体作为程序状态的引擎
REST使用**HATEOAS（Hypermedia As The Engine Of Application State 超媒体作为程序状态的引擎）**原则。
超媒体定义：有一块内容，该内容包含了指向其他内容的链接，而这些内容的格式可以不同（文本、图像、声音）。
HATEOAS想法：客户端应该与服务端通过哪些指向其他资源的链接进行交互，而这些交互有可能造成状态转移。

### 4.7.3 JSON、XML and orther


### 4.7.4 过多的约定

### 4.7.5 基于HTTP的REST的缺点
 
## 4.8实现基于事件的异步协作方式
### 4.8.1 技术选择
push和pull


1. 消息中间件
2. HTTP
- ATOM 协议


### 4.8.2 异步架构的复杂性
例如：对一个长时间请求，需要考虑响应返回时怎么处理。响应是否回到发送请求的节点？如果是。节点宕机了怎么办？如果不是，是否需要持久化信息事件到某个地方，以便后续处理？

灾难性故障转移（catastrophic failover），设置重试最大重试策略，查看或者重发有问题消息，消息医院（死信队列，失败的消息度会被转发到这里），创建一个界面显示failover消息，必要时触发一次重试。

确保各个流程有很好的监控机制，并使用关联ID，帮助追踪跨进程的请求的执行。  
参阅<b><font color="orange">《企业集成模式》</font></b>

## 4.9 服务即状态机

- 服务根据界限上下文进行划分 
- 避免对CRUD进行贫血的封装，如出现了在服务之外的其他相关的修改情况，就丧失了内聚性。
<font color="purple">
>    **把关键领域的生命周期显示建模出来，可以在唯一的一个地方处理状态冲突（如，尝试更新已经被删除的用户），还可以这些状态变化的基础上封装一些行为。**
</font>

## 4.10 响应式扩展

响应式扩展（Reactive extensions, Rx）把多个调用结果组装起来并在此基础上执行操作。调用本身可以使阻塞或者非阻塞。以往流程我们会获取一些数据，然后基于此进行操作，现在可以对操作结果进行观察，结果会根据相关数据的改变自动更新。一些Rx实现允许你对这些观察者应用某种函数变换，例如，Rz Java中可以使用类似Map或者filter这样的经典函数。
当需要做一些基于多个服务的调用操作时，可以对使用的技术栈作响应式扩展。

## 4.11 微服务世界中的DRY和代码重用的风险

Don't Repeat Yourself，避免系统行为和只是的重复。DRY可以获得重用性比较好的代码，比如说创建一个随处可用的共享库。但这种做法在微服务架构中可能存在特别大的风险。  

如果客户端通过库共享系统核心实体的公共领域对象，而所有服务业使用这个库。所以任何部分需要对库做修改时，都会引起其他部分的重新部署。如果系统通过消息队列进行通信，那么需要过滤（由不同步的部署导致的）失效的内容，忘记这么做会引起严重的问题。  

跨服务共用代码又可以能引入耦合。日志库这样的公共代码就没什么问题，因为他们对外不可见。realestate.com.au使用了很多深度定制化的服务模板来快速创建新服务。他们不会在服务之间共用代码，而是把这些代码复制到每个新的服务中，以防止耦合发生。  

在微服务内部遵循DRY，在跨服务是适当违反DRY

<b><font size="5">客户端库</font></b>  
很对团队坚持在项目启动时为服务开发一个客户端库，以降低服务使用，并且避免不同消费者之间存在重复的服务交互代码。这样的问题是如果开发服务端和客户端的是同一个技术团队，可能导致服务端逻辑泄漏到客户端中。  

AWS（Amazon Web Service）客户端库的模式，允许直接使用底层的SOAP或者REST接口。但事实上所有人终止都会使用SDK（Software Development Kits）对底层API进行抽象。  

Netflix着重强调客户端库的使用，其一避免代码重复，其二保证系统的可靠性和伸缩性。Netflix客户端会处理服务发现、故障模式、日志等方面的工作，这些方面与服务本身职责没什么关系。  
如果要使用客户端库，一定要保证其中只包处理底层传输协议的代码，如服务发现和故障处理。  

- 不要将与目标服务相关的逻辑放到客户端库中。  
- 不要将目标服务相关的逻辑放到客户端中。  
- 是否允许别人使用不同的技术栈来对底层API进行调用。  
- 最后，最后确保由客户端来负责进行客户端库的升级，保证每个服务独立于其他服务进行发布。

## 4.12 按引用访问
如果传递领域实体的相关信息。微服务应该包含核心领域实体（比如客户）全生命周期的相关操作。把客户有关的逻辑放在客服服务中的重要性。在这种设计下，如果要做任何与客户相关的改动，就必须想客户服务发起请求。遵守一个原则，客户服务应该是关于客户信息的唯一可靠来源。  

考虑这样一个例子：发货之后需要请求邮件服务发送一封邮件。一种做法，把客户邮件地址、姓名、订单详情等信息发送到邮件服务。当时邮件服务有可能会将这个请求放入队列，然后在将来的某个时间再从队列中取出来，在这个时间窗口内，客户和订单的信息有可能会发生变化。更合理方式，仅仅发送表示客户资源和订单资源的URI，然后等邮件服务器就绪是再回来查询这些信息。

基于事件的协作时，还要知道事件是否发生，到底发生了什么。所以使用引用时如果总是从客户服务去查询给定客户的相关信息，客户的负载就或过大。获取资源同时，获得资源的有效性时限，就可以进行相应的缓存，减小服务负载。

## 4.13 版本管理
### 4.13.1 尽可能推迟
对于XML使用XPath提取想要的信息  
- 容错性读取器（https://martinfowler.com/bliki/TolerantReader.html）
- Postel法则（鲁棒性原则，https://tools.ietf.org/html/rfc761），系统中每个模块都应该“宽进严出”，对自己发送的东西严格，对接受的东西宽容。

### 4.13.2 及早发现破坏性修改
使用消费者驱动契约定位这些问题。针对最新的服务对所有客户端运行测试。

### 4.13.3 使用语义化的版本管理
客户端仅仅通过查看服务的版本号，就知道他是否能够与之进行集成。`语义化版本管理（http://semve.org）`。其版本号格式MAJOR.MINOR.PATCH，其中MAJOR改变意味向后不兼容的修改，Minor意味新功能的增加，且向后兼容，PATCH对已有功能的缺陷修复。

### 4.13.4 不同接口共存
如果做了可以做的所有事情来避免对接口的修改（但是还是无法避免），下一步任务就是限制其影响。一种做法，同一服务上使新接口和老接口同时存在。发布一个破坏性修改时，部署一个同时包含新老接口的版本。一旦消费者迁移完，可以删掉该接口和代码。

扩展/收缩模型
V1--->V2--->V3过渡修改

### 4.13.5 同时使用多个版本的服务
同时运行不同版本的服务，老用户路由到老版本，新用户路由到新版本，Netflix采用此种策略。短期内使用两个版本的服务是可以接受的，尤其是做<font color="green">**`蓝绿部署`**或**`金丝雀发布`**</font>时。

## 4.14 用户界面

### 4.14.1 数字化
不应该对网页端和移动端区别对待，应该对数字化策略做全局考虑。因为很难预测用户怎样使用API，许多公司倾向把API设计的比较细粒度化。

### 4.14.2 约束
如：web要考虑用户浏览器及屏幕解析度相关的约束。移动端的带宽。平板设备缺少右键操作。

### 4.14.3 API组合
1. 为不同设备定制不同响应。一个解决方案，允许用户指定他想要获取的那些字段。
2. 谁来创建用户界面？如果UI是另一个团队创建，可能退回到以前的分层合作模式。可以使用API入口（getway）缓解通信频繁造成的流量消费问题。

### 4.14.4 UI片段组合
相比UI主动访问所有API，然后在将状态同步到UI控件，另一种选择是让服务直接暴露一部分UI，然后简单对这些片段进行组合创建出整个UI。也就是说，不在创建小部件，而是对胖客户端应用的所有内容或一个网站的所有页面进行封装。  
粗粒度的UI片段由服务端程序提供，由这些程序调用相关的API。当片段与团队所有权匹配的比较好时，这个模型可以很好的工作。  
可以使用类似服务端模板技术完成上述工作，或使用智能URI路由技术。  
优点，修改服务团队可同时对UI片段进行维护。  
缺点  
   1. 用户体验一致性，使用活样式知道（living style guides），将HTML组件、CSS及图片资源进行共享。以保障一致性。  
   2. 原生应用和胖客户端无法消费服务端提供的UI组件。解决思路使用混合方式在原生应用中嵌入HTML重用一些服务端组件，不过导致体验性降低。如果需要原生应用的体验，必须自己对API进行请求，然后本地创建和管理UI。响应式组件可以解决这一问题。
   3. 服务提供的能力难以嵌入到小部件或者页面中。考虑动态加载问题？如做搜索是，希望在键入关键字是推荐信息可以自动刷新。类似如此问题，交互越多越难把一个服务做成控件形式，也许只能通过API调用来解决。

### 4.14.5 为前端服务的后端
对与后端交互频繁的页面及需要给不同设备提供不同内容的界面来说，常用的解决方案是，使用**`服务端的聚合接口或API入口`**。该入口可以对多个后端服务调用进行编排，并为不同设备提供定制化内容。图4-19。但是这样会得到一个聚合所有服务的巨大的层。因为，所有东西都放在了一起，也就失去了用户界面之间的隔离性，限制了独立彼此进行发布的能力。一个可行实践是，保证一个这样的后端只为一个应用或用户界面服务，图4-10。  
这种模式有时也被称之为BFF（Backend For Frontends，为前端服务的后端）

### 1.14.6 一种混合方式
根据具体应用权衡上述各种方式。

## 4.15 与第三方软件集成
如果某个软件非常特殊，并且是你的战略性资产的话，那就自己构建。
### 4.15.1 缺乏控制
### 4.15.2 定制化
### 4.15.3 意大利面式的集成
### 4.15.4 在自己可控的平台进行定制化
核心思想，任何定制化都只在自己可控的平台上进行，并限制工具的消费者的数量。例子如下：
1. CMS作为服务
    选择在CMS上构建一层自己的服务作为对外的网站。图4-11
2. 多职责CRM系统

### 4.15.5 绞杀者模式
http://martinfowler.com/bliki/StranglerApplication.html
控制遗留系统和COTS平台，如考虑移除或取代他们的话。可以使用绞杀者模式（Strangler Application Pattern）。拦截对老系统的调用并重定向到新的服务中。

# 第五章 分解单块系统

## 5.1 关键是接缝
接缝可以作为服务的边界。例如，限界上下文可以作为一个寻找接缝的原则。

## 5.2 分解MusicCorp
- 产品目录
    与销售的商品相关的元数据
- 财务
    财务、支付、退款等项目的报告
- 仓库
    分发客户订单、处理退货、管理库存
- 推荐
创建包（命名空间）表示这些上下文，移动代码。例如使用Structure101可视化包之间的依赖。如果发现仓库包依赖于财务包中的代码，而真实组织中并不存在如此依赖，那么就要分析问题，并解决。

## 5.3 分解单块系统的原因
先抽取代码能获得最大收益的那部分。指导因素如下。

### 5.3.1 改变速度
### 5.3.2 团队结构
### 5.3.3 安全
### 5.3.4 技术
推荐算法使用Clojure语言中逻辑是编程库

## 5.4 杂乱的依赖
数据库是所有杂乱依赖的源头

## 5.5 数据库

## 5.6 问题的关键
第一步：查看代码中对数据库进行读写的步伐。依照限界上下文进行进行读写操作的拆分。图5-1，使用SchemaSpy（http://schemaspy.sourceforge.net/）展示表之间的关系。

## 5.7 例子：打破外键关系

跨服务的一致性检查，周期性触发清理数据的任务。

## 5.8 例子：共享静态数据

## 5.9 例子：共享数据
不同的业务代码向同一个表写入数据或读取数据的分离？领域概念不是在代码中建模，相反是在数据库中隐式建模。因此，需要添加缺失的领域概念客户。将抽象的客户概念具象化。作为一个中间步骤，创建一个新的包，叫作Customer，让后让财务和仓库这些包，通过API访问此新建的包。如图5-6

## 5.10 共享表

## 5.11 重构数据库
《Refactoring Databases》 Scott J. Ambler和Pramod J. Sadalage

- **实施分离**
先分离数据库结构

## 5.12 事务边界
### 5.12.1 再试一次
保证重试能修复全部事务问题，CAP最终一致。

### 5.12.2 终止整个操作
重置系统到某种一致状态。对已提交了的事务，解决方案是再发起一个`补偿事务`来抵消之前的操作。

### 5.12.3 分布式事务
分布式事务中的短事务一般算法使用两段式提交。

### 5.12.4 应该怎么办
如果现在有一个业务发生在跨系统的单个事务中，那么问问自己是否真的需要这么做。是否可以简单的把他们放到不同的本地事务中，然后依赖最终一致性的概念？这样构建和扩展相对容易。
如果需要保持一致性，那么尽量避免把他们放在不同的地方。实在不行，避免仅仅从纯技术上（如数据库事务）的角度考虑，而是显示的创建一个概念来表示这个事务。可以把这个概念当做一个句柄或者钩子，在此之上，进行类似补偿事务这样的操作。这也是系统中监控这些复杂概念的一种方式。举例，可以创建一个叫做“处理中的订单”的概念，围绕这个概念可以把订单和与订单相关的端到端的操作（以及异常）管理起来。

## 5.13 报告
## 5.14 报告数据库
## 5.15 通过服务调用来获取数据

## 5.16 数据导出
## 5.17 时间数据导出
## 5.18 导出数据库备份
## 5.19 走向定时
## 5.20 修改的代价
涉及面向对象系统技术CRC（class-responsiblity-collaboration，类-职责-交互）
## 5.21 理解根本原因

# 第六章 部署
## 6.1 持续集成
cI（Continuous Integration）
你真的在做CI吗
- 是否每天签入代码到主线？
应该保证代码能够与已有代码进行集成。如果你的代码和其他人的代码没有被频繁的放在一起，将来集成将会非常困难。即使你只使用生命周期很短的分支来管理这些修改，也要尽可能频繁的把代码检入到单个主线分支中。
- 是否有一组测试来验证修改？
没有对代码行为进行验证的CI不是真正的CI。
- 构建失败后，团队是否把修复CI当做第一优先级的事情来做？

## 6.2 把持续集成映射到微服务
如何在微服务、CI构建以及源代码三者之间建立合适的映射？


- 最简单的做法，所有的东西放在一起，只有一个构建。向代码库任何一次提交都会触发构建，在这个构建中运行与所有微服务相关的验证，然后产生多个构建物，所有这些都在同一个构建中完成。图6-1，因为关心的代码库少，相对简单。  
在同步发布（lock-step release）中，你需要一次性部署多个服务。  项目初期，短时期内可以采用这种模式。  
缺点，修改了用户服务的一行代码，所有服务都需要进行验证和构建，事实上他们或许并不需要重新验证和构建，这会影响CI的周期，而且不知道那个服务真正被修改了。

- 保留一个代码库，存在多个CI会分别映射到代码库的不同部分，图6-2。如果代码库的目录结构定义的合理，就会很容易把其中一部分映射到一个构建中。这个模式可能是把双刃剑。一方面简化检出/检入的流程，另一方面，它会让你觉得同时提交多个服务的修改是一件很容易的事情，从而做出将多个服务耦合在一起的修改。相对于只有一个构建的多个服务来说，已经相对来说很好了。

- 每个微服务对应自己的CI，在该服务部署到生产环境之前做一个快速验证，图6-3。这样每个微服务都有自己的代码库，分别和相应的CI绑定，代码修改时，只运行相关的测试。

## 6.3 构建流水线和持续交付




